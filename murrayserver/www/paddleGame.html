<HTML>
    <HEAD>
        <script src="/study_assets/paddleGame/libs/jquery-3.3.1.min.js"></script>
        <script src="/assets/javascripts/jatos.js"></script>
    </HEAD>
    <BODY>

    <SCRIPT>



function ready(fn) {
  if (document.readyState != 'loading'){
    fn();
  } else {
    document.addEventListener('DOMContentLoaded', fn);
  }
}

class ConnectionLost extends Error {}
class UnableToConnect extends ConnectionLost {}

class ProgressStream {

    constructor(fun) {

        this._progress = undefined;

        this._results_prom = new Promise((resolve, reject) => {
            this._resolve_result = resolve;
            this._reject_result = reject;
        });

        this._progress_prom = new Promise((resolve, reject) => {
            this._resolve_progress = resolve;
            this._reject_progress = reject;
        });

        let self = this;
        this.setProgress = function(progress) {
            self._progress = progress;
            self._resolve_progress();
        };

        let thing = fun(this.setProgress)
            .then((result) => {
                this._reject_progress();
                this._resolve_result(result);
            }, (error) => {
                this._reject_progress(error);
                this._reject_result(error);
            });
    }

    then(onSuccess, onError) {
        return this._results_prom.then(onSuccess, onError);
    }

    [Symbol.asyncIterator]() {
        var self = this;
        return {
            async next() {
                try {
                    await self._progress_prom;
                    self._progress_prom = new Promise((resolve, reject) => {
                        self._resolve_progress = resolve;
                        self._reject_progress = reject;
                    });
                    return { done: false, value: self._progress };
                } catch (e) {
                    if (e)
                        throw e;
                    else
                        return { done: true };
                }
            }
        };
    }
}


let ws;
let messages;
let player;
let serverTimeDelta;
let messageDelay = 0;
let state = { }
let notifyStateReady;
let stateReady = new Promise((resolve) => {
    notifyStateReady = resolve;
});

function adjustedTime() {
    return Date.now() + serverTimeDelta;
}

ready(async() => {

    let condOrderID;

    if (window.location.hostname === 'localhost') {
        condOrderID = 0;
    }
    else {

        jatos.onLoad(function() {
           //var username1 = jatos.studySessionData.username;
           if (jatos.urlQueryParameters.hasOwnProperty("id")) {
               //var username = "0"
               username = jatos.urlQueryParameters.id;
               jatos.studySessionData["SonaID"] = username1;
           }
           else {
               username1 = null;
               jatos.studySessionData["SonaID"] = username1;
               condOrderID = parseInt(jatos.studyResultId)%6;
            }
        });
    }

       let protocol = (window.location.protocol === 'http:' ? 'ws:' : 'wss:')
       let path = window.location.pathname.substring(0, window.location.pathname.lastIndexOf('/') + 1);
       let url = `${ protocol }//${ window.location.host }${ path }coms`;

       ws = new WebSocket(url);

       await new Promise(function(resolve, reject) {
           ws.onopen = () => resolve();
           ws.onerror = () => reject(new UnableToConnect());
       });

       messages = new ProgressStream((setProgress) => {
           ws.onmessage = (message) => setProgress(message.data);
           return new Promise((resolve, reject) => {
               ws.onclose = () => reject(new ConnectionLost());
           });
       });

       readMessages();
       writeMessages();
       await stateReady;

       initialise();
   });


class PaddleHistory {
    constructor() {
        this.retain = 5000;
        this.history = [ ]
    }

    add(time, pos) {
        while (this.history.length > 1
                && (time - this.history[this.history.length - 1].time) > this.retain) {
            this.history.pop();
        }
        this.history.unshift({ time, pos });
    }

    get(time, currentPos) {

        if (this.history.length === 0)
            return currentPos;

        if (time > this.history[0].time)
            return this.history[0].pos;

        // should use a binary search of course, but whatevs
        for (let i = 1; i < this.history.length; i++) {
            if (time > this.history[i].time) {
                let intervalStart = this.history[i-1].time;
                let intervalEnd = this.history[i].time;
                let posStart = this.history[i-1].pos;
                let posEnd = this.history[i].pos;
                let weight = (time - intervalStart) / (intervalEnd - intervalStart);
                let pos = (posEnd - posStart) * weight + posStart;

                return pos;
            }
        }

        return this.history[this.history.length-1].pos;
    }
}

let paddle1History = new PaddleHistory();
let paddle2History = new PaddleHistory();


  </SCRIPT>

    <canvas id="canvas" width="800" height="600" style="width: 100%; height:100%"></canvas>
    <script>

    var skipIntro = false;

    // Define variables
        var nBlocks             = 3;

        // workload
        var workloadLevels      = [1,3,6,9];
        var trialDuration       = 20;           // seconds
        var dirInst             = 5;            // second intervals to display practice trial instructions
        var frameRate           = 10;
        var sharedColour        = "DarkMagenta";
        var p1Colour            = "FireBrick";
        var p2Colour            = "RoyalBlue";
        var pColours            = [p1Colour, p2Colour];
        var frameColour         = "ivory";

        // GameFrame
        var drtWidth            = 800;
        var frameWidth          = drtWidth*0.9;
        var frameHeight         = 600;
        var frameLeft;
        var frameRight;
        var frameTop;
        var frameBottom;

        // DRT

        var drtLeft;
        var drtRight;
        var drtOn               = "chartreuse";
        var drtOff              = "black";
        var drtMin              = 3;
        var drtMax              = 5;
        var respWin             = 2.5;
        var drtDur              = 1;
        let drtResp1            = false;
        let drtOnsets;
        var onsets              = [];   // used to save the onset times for each trial

        var LHdrtRespKey        = "38"
        var RHdrtRespKey        = "90"

        var plyr1DRTrespKey;
        var plyr2DRTrespKey;

        var hand1;
        var hand2;

        // Timing
        var startDate;
		var startTime;
		var currentTime;
		var endDate;
		var endTime;
		var rt1 = [];
        var rt2 = [];
        var fa1 = [];
        var fa2 = [];
        var missCode = -1;
        
        var startingTime;
        var lastTime;
        var totalElapsedTimed;
        var elapsedSinceLastLoop;
        var calc = pSpeed/1000;

        // Experiment control
        var nCurrentBlock;
        var nCurrentTrial;
        var bInTrial                = false;
        var bInInstructions1        = false;
        var bInInstructionsOnline   = false;
		var bInInstructions2        = false;
        var bInInstructions3        = false;
		var bInEndOfBlock           = false;
		var bInBlockInstructions    = false;
        var bInPractice             = false;
        var blockBreakTime          = 1; // 20
        var trialBreakTime          = 1; // 5
        var proceed                 = false;
        var bInTrialBreak           = false;
        var justOncePlease          = true;
        var dispCont                = true;

        var username1;
        var username2;

        // Trial Start
        let startCount          = 0;
        let start;
        var interval;
        var timeout;

        // Paddles
        var paddle1;
        var paddle2;
        var nPaddles            = 2;
        var pWidth              = frameWidth*0.1;
        var pHeight             = pWidth*0.12;
        var pSpeed              = Math.round(pHeight/2);
        let p1Right             = false;
        let p1Left              = false;
        let p2Right             = false;
        let p2Left              = false;
        let p1Start;
        let p2Start;
        var py;
        var LHleft              = "90"; //Z
        var LHright             = "67"; //C
        var RHleft              = "37"; //left arrow
        var RHright             = "39"; // right arrow
        var left;
        var right;              

        if (skipIntro){
            left = RHleft; 
            right = RHright; 
            plyr1DRTrespKey = RHdrtRespKey;
        }
        
        var p1Hand              = [];
        var p1HandChosen        = false;
        var p2HandChosen        = false;
        var rtMin               = 0.1; // tenth of a second - used to clean RT times as they're made
        var counter1 = true; // these are response counters so we don't have 100 RTs saved as hits for each DRT stimulus event.
        var counter2 = true;


        // Balls
        var bRad                = pHeight*0.9;
        var bSpeed              = Math.ceil(pSpeed*0.8);
        let moving              = false;
        let lowLim              = 35;
        let upperLim            = 155;
        let p1Balls             =[];
        let p2Balls             =[];
        let allBalls            =[];
        var bx;
        var by;
        var bAngles;

        // Scoring
        var hits1               = 0;
        var miss1               = 0;
        let score1              = 0;
        var hits2               = 0;
        var miss2               = 0;
        let score2              = 0;
        var teamScore           = 0;
        var p1CumulativeScore   = 0;
        var p2CumulativeScore   = 0;
        var teamCumulativeScore = 0;
        var p1teamScore         = 0;
        var p2teamScore         = 0;

        // save Data
        var paddleCoords        = [];
        var ballCoords          = [];
        var scoreData           = [];
        var drtData             = [];

        var outputSummary;

        // Sprite Classes
        class Ball {
            constructor(x, colour, ballId, angle) {
                this.x      = x;
                this.y      = by;
                this.size   = bRad;
                this.colour = colour;
                this.speed  = bSpeed;
                this.angle  = -deg2rad(angle);
                this.identity = ballId;
                this.xCoords = [];
                this.yCoords = [];
            }
            move(paddlePos1,paddlePos2,elapsed){
                
                let identity = this.identity;
                let ballId = this.identity;

                if (state.block.block_type === "nonCol"){
                    if (identity>=9){
                        if (state.block.n_balls == 1){identity = identity - 8}
                        else if (state.block.n_balls == 3){identity = identity - 6}
                        else if (state.block.n_balls == 6){identity = identity - 3}
                    }
                }
                if (state.balls) {
                    let s = state.balls[identity];
                    this.speed = s.speed;
                    this.angle = s.angle;

                    let bounds = {
                        left: frameLeft + bRad,
                        top: bRad,
                        right: frameRight - bRad,
                        bottom: frameHeight - bRad,
                        paddle: py - bRad,
                    };

                    function move(x, y, speed, angle, elapsed) {
                        let xe = x + speed * Math.cos(angle) * elapsed / 1000 / 0.02;
                        let ye = y + speed * Math.sin(angle) * elapsed / 1000 / 0.02;
                        return { x: xe, y: ye };
                    }

                    function determinePaddleLineCrossing(x, y, speed, angle, elapsed) {

                        let end = move(x, y, speed, angle, elapsed);

                        if (start.y > bounds.paddle || end.y < bounds.paddle)
                            // did not pass through paddle line
                            return;

                        let prop = (bounds.paddle - y) / (end.y - y);
                        let xAtCrossing = (end.x - x) * prop + x;
                        elapsed = elapsed * prop;
                        return { x: xAtCrossing, elapsed };
                    }

                    function determineResultantAngle(crossing, angle, paddleX) {
                        if (paddleX === undefined)
                            return;
                        if (crossing.x < paddleX - bRad || crossing.x > paddleX + pWidth + bRad)
                            return;

                        let impact = (crossing.x + bRad / 2) - (paddleX + pWidth / 2)
                        let offset = impact / (pWidth / 2) / 2
                        let newAngle = -angle + offset;

                        if (newAngle <= -deg2rad(155) || newAngle >= -deg2rad(35))
                            return -angle;
                        else
                            return newAngle;
                    }

                    function determinePaddleCollision(x, y, speed, angle, elapsed, p1, p2) {

                        let crossing = determinePaddleLineCrossing(x, y, speed, angle, elapsed);
                        if ( ! crossing)
                            return undefined;

                        let remaining = elapsed - crossing.elapsed;
                        let then = adjustedTime() - remaining;
                        let paddle1x;
                        let paddle2x;

                        if (p1)
                            paddle1x = paddle1History.get(then);
                        if (p2)
                            paddle2x = paddle2History.get(then);

                        let angle1 = determineResultantAngle(crossing, angle, paddle1x);
                        let angle2 = determineResultantAngle(crossing, angle, paddle2x);

                        let rAngle;
                        if (angle1 && angle2)
                            rAngle = (angle1 + angle2) / 2;
                        else if (angle1)
                            rAngle = angle1;
                        else if (angle2)
                            rAngle = angle2;
                        else
                            return undefined;

                        return { x: crossing.x, y: bounds.paddle, angle: rAngle, elapsed: crossing.elapsed };
                    }

                    function determineLeftCollision(x, y, speed, angle, elapsed) {
                        let end = move(x, y, speed, angle, elapsed);
                        if (end.x < bounds.left) {
                            let prop = (x - bounds.left) / (x - end.x);
                            x = bounds.left;
                            y = (end.y - y) * prop + y;
                            elapsed = elapsed * prop;
                            angle = deg2rad(180) - angle;
                            return { x, y, speed, angle, elapsed };
                        }
                    }

                    function determineRightCollision(x, y, speed, angle, elapsed) {
                        let end = move(x, y, speed, angle, elapsed);
                        if (end.x > bounds.right) {
                            let prop = (bounds.right - x) / (end.x - x);
                            x = bounds.right;
                            y = (end.y - y) * prop + y;
                            elapsed = elapsed * prop;
                            angle = deg2rad(180) - angle;
                            return { x, y, speed, angle, elapsed };
                        }
                    }

                    function determineTopCollision(x, y, speed, angle, elapsed) {
                        let end = move(x, y, speed, angle, elapsed);
                        if (end.y < bounds.top) {
                            let prop = (y - bounds.top) / (y - end.y);
                            y = bounds.top;
                            x = (end.x - x) * prop + x;
                            elapsed = elapsed * prop;
                            angle = -angle;
                            return { x, y, speed, angle, elapsed };
                        }
                    }

                    function determineBottomCollision(x, y, speed, angle, elapsed) {
                        let end = move(x, y, speed, angle, elapsed);
                        if (end.y > bounds.bottom) {
                            let prop = (bounds.bottom - y) / (end.y - y);
                            x = (end.x - x) * prop + x;
                            y = bounds.top;
                            elapsed = elapsed * prop;
                            return { x, y, speed, angle, elapsed };
                        }
                    }


                    let playerId = state.player_id;

                    let p1 = false
                    let p2 = false;

                    if (state.block.block_type == 'nonCol') {
                        if ((ballId < 9 && playerId == 0) || (ballId >= 9 && playerId == 1))
                            p1 = true;
                        else
                            p2 = true;
                    }
                    else {
                        p1 = true;
                        p2 = true;
                    }

                    let x = s.x;
                    let y = s.y;
                    let speed = s.speed;
                    let angle = s.angle;

                    while (true) {
                        let collisions = [
                            determineLeftCollision(x, y, speed, angle, elapsed),
                            determineRightCollision(x, y, speed, angle, elapsed),
                            determineTopCollision(x, y, speed, angle, elapsed),
                            determineBottomCollision(x, y, speed, angle, elapsed),
                            determinePaddleCollision(x, y, speed, angle, elapsed, p1, p2),
                        ];

                        let earliest = collisions.find((x, index, array) => {
                            if (x === undefined)
                                return false;
                            for (let i = index + 1; i < array.length; i++) {
                                if (array[i] && x.elapsed > array[i].elapsed)
                                    return false;
                            }
                            return true;
                        });

                        if (earliest) {
                            x = earliest.x;
                            y = earliest.y;
                            angle = earliest.angle;
                            elapsed = elapsed - earliest.elapsed;
                        }
                        else {
                            break;
                        }
                    }

                    let pos = move(x, y, speed, angle, elapsed)
                    this.x = pos.x;
                    this.y = pos.y;


                    // // Paddle contact
                    // function returnAngle(ballx, paddlex, angle, x, y, speed){
                    //     let impact = (ballx + bRad) - (paddlex + (0.5*pWidth));
                    //     let offset = impact / (pWidth*0.5)/2;
                    //     if (-angle+offset <= -deg2rad(155)){
                    //         angle = -angle;
                    //     } else if (-angle+offset>=-deg2rad(35)){
                    //         angle = -angle;
                    //     } else {
                    //         angle = -angle+offset
                    //     }
                    //     x = x + speed * Math.cos(angle) * elapsed / 1000 / 0.02;
                    //     y = y + speed * Math.sin(angle) * elapsed / 1000 / 0.02;
                    //     return [angle, x, y]
                    // }
                                        
                }
            }

            movePractice(paddlePos1){
                let dx = this.x + this.speed*Math.cos(this.angle);
                let dy = this.y + this.speed*Math.sin(this.angle);
                let angle = this.angle;

                if (dx > frameRight - bRad){
                    dx = frameRight - (dx - frameRight) - bRad;
                    angle = Math.PI - angle;
                }
                if (dx < frameLeft + bRad) {
                    dx = frameLeft + (frameLeft - dx) + bRad
                    angle = Math.PI - angle;
                }
                if (dy < frameTop + bRad) {
                    dy = frameTop + (frameTop - dy) + bRad
                    angle = -angle;
                }
                if (dy > frameBottom) {
                    dy -= frameBottom - frameTop - bRad;


                } else {
                    miss1++;
                }
                if (dy > py-bRad && dy < py) {
                    if (dx > paddlePos1 - bRad && dx < paddlePos1 + pWidth + bRad) {
                        let impact  = (dx+bRad) - (paddlePos1+(0.5*pWidth));
                        let offset  = impact/(pWidth*0.5)/2;
                        if (-angle+offset <= -deg2rad(upperLim)){
                            angle = -angle;
                        } else if (-angle+offset>=-deg2rad(lowLim)){
                            angle = -angle;
                        } else {
                            angle = -angle+offset
                        }
                        dy = py - (py-dy) - bRad
                        hits1++;
                    }
                }
                this.x = dx;
                this.y = dy;
                this.angle = angle;
            }
            draw(){
                expContext.beginPath();
                expContext.arc(this.x, this.y, this.size, 0, Math.PI*2);
                expContext.fillStyle = this.colour;
                expContext.fill();
                expContext.stroke();
            }
        }
        class Paddle {
            constructor(x,colour){
                this.x      = x;
                this.colour = colour;
                this.coords = [];
                }
            move(mvLeft = false, mvRight = false, speed) {
                let playerId = state.player_id;
                let otherId = playerId === '0' ? '1' : '0';
                let theirPos = state.players[otherId].pos;

                if (mvLeft){
                    this.x -= speed;
                    if (this.x < frameLeft) {
                        this.x = frameLeft;
                    }
                }
                if (mvRight){
                    this.x  += speed;
                    if (this.x + pWidth > frameRight){
                        this.x = frameRight - pWidth;
                    }
                }
            }

            draw(){
                expContext.beginPath();
                expContext.rect(this.x,py,pWidth,pHeight);
                expContext.fillStyle = this.colour;
                expContext.fill();
                expContext.stroke();
            }
        }
        class DRT {
            constructor(){
            }
            draw(drtColour){
                expContext.beginPath();
                expContext.rect(drtLeft,frameTop,drtWidth,frameHeight);
                expContext.fillStyle = drtColour;
                expContext.fill();
                expContext.stroke();
            }
        }

        function roundedRect(ctx,x,y,width,height,radius,fill,stroke){
            ctx.strokeStyle = "white";
            ctx.beginPath();
            ctx.moveTo(x+radius,y);
            ctx.arcTo(x+width,y,x+width,y+radius,radius);
            ctx.arcTo(x+width,y+height,x+width-radius,y+height,radius);
            ctx.arcTo(x,y+height,x,y+height-radius,radius);
            ctx.arcTo(x,y,x+radius,y,radius);
            if(fill){
                ctx.fill();
            }
            if(stroke){
                ctx.stroke();
            }
            ctx.strokeStyle = "black";
        }
        function drawKeyDepth(x, y) {
            expContext.strokeStyle = "white";
            expContext.beginPath();
            expContext.moveTo(x - 10, y - 10);
            expContext.lineTo(x + 30, y + 30);
            expContext.moveTo(x + 29, y - 9);
            expContext.lineTo(x - 10, y + 29);
            expContext.stroke();
            expContext.strokeStyle = "black";
        }
        function drawKey(ctx, faceVal, x, y, width, height, radius, fill, stroke, specialChar){
            // Perimeter / Base
            ctx.lineWidth = 4;
            roundedRect(ctx,x-10,y-10,width, height, radius, false, stroke);
            // Key top
            expContext.lineWidth = 3;
            drawKeyDepth(x,y);
            expContext.fillStyle = "black";
            roundedRect(ctx,x-5,y-6,width-10,height-10, radius-1, true, stroke);
            // Key Content
            expContext.fillStyle = "white";
            if (specialChar){ // used for the directional arrows
                var uni = '"\\u' + faceVal+'"';
                var faceVal = eval(uni);
            }
            expContext.fillText(faceVal, x+10, y+10);
            ctx.lineWidth = 1;
        }
        function keyInsts(p1, p2, drt1, drt2){
            // Player Keys
            if (p1){
                expContext.fillStyle = p1Colour;
                expContext.fillStyle = "white";
                if (drt1 == LHdrtRespKey){
                    drawKey(expContext,"2191",expCanvas.width*0.67-15,expCanvas.height/2+50, 40, 40, 3,true,true,true);
                    drawKey(expContext,"Z",expCanvas.width/3-25,expCanvas.height/2+50, 40, 40, 3,true,true,false);
                    drawKey(expContext,"C",expCanvas.width/3+25,expCanvas.height/2+50, 40, 40, 3,true,true,false);
                    expContext.fillText("Left", expCanvas.width/3-30,expCanvas.height/2+100);
                    expContext.fillText("Right", expCanvas.width/3+50,expCanvas.height/2+100);
                    expContext.fillText("Response", expCanvas.width*0.67,expCanvas.height/2+100);
                    expContext.fillText("Non-Dominant", expCanvas.width*0.67,expCanvas.height/2+25);
                    expContext.fillText("Dominant Hand", expCanvas.width/3,expCanvas.height/2+25);
                } else if (drt1 == RHdrtRespKey){
                    drawKey(expContext,"Z",expCanvas.width/3-15,expCanvas.height/2+50, 40, 40, 3,true,true,false);
                    drawKey(expContext,"2190",expCanvas.width*0.67-25,expCanvas.height/2+50, 40, 40, 3,true,true,true);
                    drawKey(expContext,"2192",expCanvas.width*0.67+25,expCanvas.height/2+50, 40, 40, 3,true,true,true);
                    expContext.fillText("Left", expCanvas.width*0.67-30,expCanvas.height/2+100);
                    expContext.fillText("Right", expCanvas.width*0.67+50,expCanvas.height/2+100);
                    expContext.fillText("Response", expCanvas.width/3,expCanvas.height/2+100);
                    expContext.fillText("Non-Dominant", expCanvas.width/3,expCanvas.height/2+25);
                    expContext.fillText("Dominant Hand", expCanvas.width*0.67,expCanvas.height/2+25);
                }
            }
        }

        // Handling input
        document.addEventListener("keydown",keyDownHandler, false);
        document.addEventListener("keyup", keyUpHandler, false);
        function keyDownHandler(e) {
            if (e.keyCode == right) {
                p1Right = true;
            } else if (e.keyCode == left) {
                p1Left = true;
            }

            if (e.keyCode == plyr1DRTrespKey) {
                drtResp1 = true;
            } 

            if (event.keyCode === 9){// Disable Tab key function
                event.preventDefault();
            }

            if (bInInstructions1){
				if (event.keyCode == 32) {
                    event.preventDefault();
                    bInInstructions1 = false;
                    instructionsOnline()
                }
            } else if (bInInstructionsOnline){
                if (event.keyCode == 32){
                    event.preventDefault();
                    bInInstructionsOnline = false;
                    instructions2();
                }
                if (event.keyCode == 66){ // b
                    bInInstructionsOnline = false;
                    instructions1();
                }
            } else if (bInInstructions2){
                if (p1Hand.length == 0 && !p1HandChosen){
                    if (e.keyCode == LHdrtRespKey){
                        hand1 = 'left';
                        p1Hand.push(LHdrtRespKey);
                        plyr1DRTrespKey = LHdrtRespKey;
                        left    = LHleft;
                        right   = LHright;
                        p1HandChosen = true;
                    } else if (e.keyCode == RHdrtRespKey && !p1HandChosen){
                        hand1 = 'right';
                        p1Hand.push(RHdrtRespKey);
                        plyr1DRTrespKey = RHdrtRespKey;
                        left    = RHleft;
                        right   = RHright;
                        p1HandChosen = true;
                    }
                }
                if (p1Hand.length == 1 && p1HandChosen){
                    keyInsts(true,true,plyr1DRTrespKey,plyr2DRTrespKey);
                    p1HandChosen = true;
                }

                if (p1Hand.length == 1){
                    if (p2HandChosen){
                        keyInsts(false,true,plyr1DRTrespKey,plyr2DRTrespKey);
                        expContext.fillText("Press 'spacebar' to continue", expCanvas.width*.75,expCanvas.height-50);
                        p2HandChosen = false;
                    }
                    if (event.keyCode == 32) {
                        event.preventDefault();
                        bInInstructions2 = false;
                        instructions3();
                        keyInsts(true,true,plyr1DRTrespKey,plyr2DRTrespKey);
                    }
                } else if (event.keyCode == 66){ // b
                    bInstructions2 = false;
                    instructionsOnline();
                }
            } else if (bInInstructions3){
                if (event.keyCode == 32) {
                    event.preventDefault();
                    bInInstructions3 = false;

                    if (skipIntro){
                        blockInst(state.block.block_type,nCurrentBlock);
                    } else {
                        practiceTrial();
                    }
                } else if (event.keyCode == 66){ // b
                    bInstructions3 = false;
                    p1HandChosen = true;
                    p2HandChosen = true;
                    instructions2();
                    keyInsts(true,true,plyr1DRTrespKey,plyr2DRTrespKey);
                    expContext.fillText("Press 'spacebar' to continue", expCanvas.width*.75,expCanvas.height-50);
                    expContext.fillStyle = "red";
                    expContext.font="30px Arial";
                    expContext.fillText("Controls cannot be changed.",expCanvas.width/2,expCanvas.height-160);
                    expContext.fillStyle = frameColour;
                    expContext.font="16px Arial";
                }
            }
            if (bInTrial){
                if (bInPractice){
                    if (startCount == 0 && event.keyCode == 32){
                        event.preventDefault();
                        moving = true;
                        start = Date.now();
                        startCount++
                    }
                }

                if (event.keyCode == plyr1DRTrespKey){
                    event.preventDefault();
                    drtResp1 = true;
                }
            }
            if (bInBlockInstructions){
                if (event.keyCode == 32 && proceed){
                    ws.send('{"status":"ready"}')
                    intertrialWaiting()
                }
            }
            if (bInTrialBreak){
                if (event.keyCode == 32 && proceed){
                    bInTrialBreak = false;
                    scoreReset();
                    if (nCurrentTrial<state.maxTrials){
                        ws.send('{"status":"ready"}')
                        intertrialWaiting()
                    } else if(nCurrentTrial>=state.maxTrials){
                        nCurrentBlock++;
                        if (nCurrentBlock == nBlocks){
                            expEnd();
                        } else {
                            blockInst(state.block.block_type,nCurrentBlock);
                        }
                    }
                    proceed = false;
                }
            }
        }
        function keyUpHandler(e) {
            if (e.keyCode == right) {
                p1Right = false;
            } else if (e.keyCode == left) {
                p1Left  = false;
            }
            // DRT Response
            if (e.keyCode == plyr1DRTrespKey) {
                drtResp1 = false;
                ws.send(JSON.stringify({ 'drtResp': false }));
            } 

        }

        // Set Instructions
        function waitingRoom(){
            bInWaiting = true;
            drawCanvas();
			expContext.fillStyle = frameColour;
            expContext.font="30px Arial";
			expContext.textAlign = "center";
            expContext.fillText("Welcome to the 'Team Spirit' waiting room!",expCanvas.width/2,expCanvas.height/4-100);
            expContext.font="16px Arial";
            expContext.fillText("We are currently waiting for player 2 to join.",expCanvas.width/2,expCanvas.height/4-50);

            expContext.fillText("During this experiment you will play an online multiplayer arcade-style game.",expCanvas.width/2,expCanvas.height/4);
            expContext.fillText("The formal experiment explanation will automatically commence once player 2 has joined.",expCanvas.width/2,expCanvas.height/4+25);
        }
        
        function instructions1(){
            bInInstructions1 = true;
            drawCanvas();
			expContext.fillStyle = frameColour;
            expContext.font="30px Arial";
			expContext.textAlign = "center";
            expContext.fillText("Welcome to Team Spirit!",expCanvas.width/2,expCanvas.height/4-100);
            expContext.font="16px Arial";
            expContext.fillText("This experiment will examine your performance during a multiplayer arcade-style game.",expCanvas.width/2,expCanvas.height/4-50);
            expContext.fillText("1/4", expCanvas.width*.75,25);
            expContext.fillText("The game involves a set of balls flying around the screen and two paddles.",expCanvas.width/2,expCanvas.height/4);
            expContext.fillText("Your task is to move your paddle to deflect as many balls as you can within the time limit.",expCanvas.width/2,expCanvas.height/4+25);
            expContext.fillText("You score points for each 'hit' and lose points for each 'miss'.",expCanvas.width/2,expCanvas.height/4+50);
            expContext.fillText("The time remaining and your score will be displayed throughout each trial.",expCanvas.width/2,expCanvas.height/4+75);

            expContext.fillText("The game runs over 3 blocks of 16 trials, where each trial lasts 60 seconds.", expCanvas.width/2,expCanvas.height/4+125);
            expContext.fillText("There is a forced 20 second break between blocks but you can break for as long as you need.", expCanvas.width/2,expCanvas.height/4+150);
            expContext.fillText("The experiment will take approximately 60 minutes and you will be reimbursed 1 SONA point per half hour.", expCanvas.width/2,expCanvas.height/4+175);
            expContext.fillText("You may exit the study at any time without penalty by closing your browser window.", expCanvas.width/2,expCanvas.height/4+200);

            expContext.fillText("Press 'spacebar' to continue", expCanvas.width*.75,expCanvas.height-50);
        }
        // Perhaps include another page here that explains to them the nature of the multiplayer game. For example:
        function instructionsOnline(){
            bInInstructionsOnline = true;
            drawCanvas();
			expContext.fillStyle = frameColour;
            expContext.font="16px Arial";
            expContext.fillText("This experiment is unique in that you will be playing with and against another participant.",expCanvas.width/2,expCanvas.height/4-50);
            expContext.fillText("2/4", expCanvas.width*.75,25);
            expContext.fillText("You are both currently reading through the instructions at your own pace but when the experiment",expCanvas.width/2,expCanvas.height/4); 
            expContext.fillText("begins you will both be required to indicate that you are ready before the next trial begins.",expCanvas.width/2,expCanvas.height/4+25);
            expContext.fillText("We understand that these tasks can become tedious however, as a courtesy to",expCanvas.width/2,expCanvas.height/4+75);
            expContext.fillText("the potential time constraints of your fellow participant, it important that", expCanvas.width/2,expCanvas.height/4+100);
            expContext.fillText("you remain engaged with and progress through the inter-trial and inter-block breaks.",expCanvas.width/2,expCanvas.height/4+125);

            expContext.fillText("Press 'spacebar' to continue", expCanvas.width*.75,expCanvas.height-50);
            expContext.fillText("Press 'b' to return", expCanvas.width*.25,expCanvas.height-50);
        }
        function instructions2(){
            bInInstructions2 = true;
            drawCanvas();
            expContext.fillStyle = frameColour;
            expContext.fillText("3/4", expCanvas.width*.75,25);
            expContext.fillText("Your paddle is red whereas your fellow participants paddle is blue.",expCanvas.width/2,expCanvas.height/4-100);
            expContext.fillText("Your score is shown in the top left corner of each trial and the score",expCanvas.width/2,expCanvas.height/4-75);
            expContext.fillText("of your fellow participant is shown in the top right corner of each trial.",expCanvas.width/2,expCanvas.height/4-50);
            expContext.fillText("Along with controlling paddle movement you will also be required",expCanvas.width/2,expCanvas.height/4);
            expContext.fillText("to respond to a flashing green light using your non-dominant hand.",expCanvas.width/2,expCanvas.height/4+25);
            expContext.fillText("A more detailed explanation of this light is provided on the following page.",expCanvas.width/2,expCanvas.height/4+50);
            expContext.fillText("For now, please indicate if you are right-handed by pressing 'Z' or if you are left-handed press the UP arrow.",expCanvas.width/2,expCanvas.height/4+100);

            expContext.fillText("Please ensure that your dominant hand controls the paddle movement keys and",expCanvas.width/2,expCanvas.height-125);
            expContext.fillText("your non-dominant hand controls the response key.",expCanvas.width/2,expCanvas.height-100);
            expContext.fillText("Press 'spacebar' to continue", expCanvas.width*.75,expCanvas.height-50);
            expContext.fillText("Press 'b' to return", expCanvas.width*.25,expCanvas.height-50);
        }
        function instructions3(){
            bInInstructions3 = true;
            drawCanvas();
            expContext.fillRect(0, 0, expCanvas.width, expCanvas.height);
			expContext.fillStyle = frameColour;
			expContext.font="16px Arial";
			expContext.textAlign = "center";
            expContext.fillText("4/4", expCanvas.width*.75,25);
            expContext.fillText("Throughout the experiment, two panels along either side of the screen will flash green.",expCanvas.width/2,expCanvas.height/4-100);
            expContext.fillText("The light will display briefly or until both players respond but you can",expCanvas.width/2,expCanvas.height/4-50);
            expContext.fillText("still respond to the light for a brief time after it disappears.",expCanvas.width/2,expCanvas.height/4-25);
            expContext.fillText("Please try to respond quickly and accurately to these lights.",expCanvas.width/2,expCanvas.height/4+25);
            expContext.fillText("The response key is shown below.",expCanvas.width/2,expCanvas.height/4+50);
            expContext.fillText("A brief walkthrough trial will commence following this screen.",expCanvas.width/2,expCanvas.height/4+100);


            expContext.fillText("Please ensure that your dominant hand controls the paddle movement keys and",expCanvas.width/2,expCanvas.height-125);
            expContext.fillText("your non-dominant hand controls the response key.",expCanvas.width/2,expCanvas.height-100);
            expContext.fillText("Press 'spacebar' to continue", expCanvas.width*.75,expCanvas.height-50);
            expContext.fillText("Press 'b' to return", expCanvas.width*.25,expCanvas.height-50);
        }

        function drawPracInst(time){
            expContext.fillStyle = "red";
            expContext.fillText("PRACTICE TRIAL",frameLeft+frameWidth/2,frameTop+50);
            expContext.fillStyle = "black";
            if (!moving){
                expContext.font = "20 px Arial";
                expContext.fillStyle = "rgb(0,0,0)";
                expContext.fillText("Each trial contains a different number of balls but",frameLeft+frameWidth/2,frameBottom-frameHeight/4-25);
                expContext.fillText("they will always start from the bottom of the screen and fly upward.",frameLeft+frameWidth/2,frameBottom-frameHeight/4);
                expContext.fillText("Experiment trials will begin automatically. For now, press 'space bar' to start the trial",frameLeft+frameWidth/2,frameBottom-frameHeight/4+25);
            } else if (time > trialDuration-dirInst){
                if (plyr1DRTrespKey == RHdrtRespKey){
                    expContext.fillText("Press left arrow to move left",frameLeft+frameWidth/2,frameBottom-frameHeight/4);
                    expContext.fillText("Press right arrow to move right",frameLeft+frameWidth/2,frameBottom-frameHeight/4+25);
                } else {
                    expContext.fillText("Press 'Z' to move left",frameLeft+frameWidth/2,frameBottom-frameHeight/4);
                    expContext.fillText("Press 'C' to move right",frameLeft+frameWidth/2,frameBottom-frameHeight/4+25);
                }
            } else if (time < trialDuration-dirInst && time > trialDuration-dirInst*4){
                expContext.fillText("Overall score is computed from your hits AND misses!",expCanvas.width/2,frameTop+frameHeight/5);
                ;
                expContext.fillText("If both paddles hit the same ball at the same time you each score half a hit-point.",expCanvas.width/2,frameTop+frameHeight/5+20);
            } else if (time < trialDuration-dirInst && time > trialDuration-dirInst*5){
                expContext.fillText("Trials last 60 seconds.",expCanvas.width/2,frameTop+frameHeight/5);
                expContext.fillText("Your score can be seen throughout the trial.",expCanvas.width/2,frameTop+frameHeight/5+20);
                expContext.fillText("The maximum score for a trial is 1000.",expCanvas.width/2,frameTop+frameHeight/5+40);

            } else if (time < trialDuration-dirInst*5 && time > trialDuration-dirInst*8){
                expContext.fillText("The panels on the side have now been activated.",expCanvas.width/2,frameTop+frameHeight/5);
                expContext.fillText("They will regularly flash green throughout the game.",expCanvas.width/2,frameTop+frameHeight/5+20);
                expContext.fillText("The light stays on briefly or until both players respond.",expCanvas.width/2,frameTop+frameHeight/5+40);
                expContext.fillText("You need to respond as quickly and accurately as possible.",expCanvas.width/2,frameTop+frameHeight/5+60);
                expContext.fillText("Light Response:", expCanvas.width/2, frameBottom-frameHeight/4-25);
                if (plyr1DRTrespKey == RHdrtRespKey){
                    expContext.fillText("Press 'Z'", expCanvas.width/2, frameBottom-frameHeight/4);
                } else {
                    expContext.fillText("Press 'UP' arrow", expCanvas.width/2, frameBottom-frameHeight/4);
                }
            }
        }

        function blockInst(blockTypes,count){
            drawCanvas();
            bInBlockInstructions    = true;
            count++;
            p1CumulativeScore  = 0; // the cumulative scores for both players throughout each block
            p2CumulativeScore  = 0;
            scoreReset();
			expContext.fillStyle    = frameColour;
            expContext.font         ="16px Arial";
            expContext.textAlign    = "center";
            if (count !== 1){
                expContext.fillText("Please take a short 20 second break before beginning the next block.",expCanvas.width/2, expCanvas.height/4-150);
            }
            expContext.fillText("You will now begin block "+count+" of "+nBlocks,expCanvas.width/2,expCanvas.height/4-100);
            count--;

            if (state.block.block_type == "nonCol"){
                expContext.fillText("During this block you will only be able to interact with balls that match the colour of your paddle.",expCanvas.width/2,expCanvas.height/4-50);
            } else if (state.block.block_type == "col"){
                expContext.fillText("During this block you must work together.",expCanvas.width/2,expCanvas.height/4-25);
                expContext.fillText("Both of your hits and misses count toward the team score.",expCanvas.width/2,expCanvas.height/4);
            } else if (state.block.block_type == "com"){
                expContext.fillText("During this block you must compete against each other to outscore your opponent.",expCanvas.width/2,expCanvas.height/4-50);
                expContext.fillText("Any 'miss' is scored against you both but your 'hits' are your own.",expCanvas.width/2,expCanvas.height/4-25);
            }
            expContext.fillText("Score as high as you can but don't forget to",expCanvas.width/2,expCanvas.height/4+25);
            expContext.fillText("respond quickly and accurately to the flashing light.",expCanvas.width/2,expCanvas.height/4+50);
            if (count == 0){
                timeout = setTimeout(timedContinue,trialBreakTime*1000);
            } else {
                timeout = setTimeout(timedContinue,blockBreakTime*1000);
            }
        }

        function intertrialWaiting(){
            drawCanvas();
            expContext.fillStyle = frameColour;
            expContext.textAlign = 'center';
            expContext.font = "26px Arial";
            expContext.fillText("WAITING",expCanvas.width/2, expCanvas.height/3 - 100);
            expContext.font = "16px Arial";
            expContext.fillText("Player 1: Ready",expCanvas.width/2, expCanvas.height/3);
            expContext.fillText("Waiting for Player 2", expCanvas.width/2, expCanvas.height/3 + 25);
            expContext.fillText("Please wait for player 2.", expCanvas.width/2, expCanvas.height/3 + 100);
            expContext.fillText(" The trial will commence once they have indicated they are ready.", expCanvas.width/2, expCanvas.height/3 + 125);

        }

        // Set Functions
		function initialise() {
			nCurrentBlock       = 0; // start at zero
			expCanvas           = document.getElementById("canvas");
			expContext          = expCanvas.getContext("2d");
			expContext.fillStyle= frameColour;
			expContext.fillRect(0, 0, expCanvas.width, expCanvas.height);
            frameLeft           = drtWidth*0.05;
			frameRight          = drtWidth*0.95;
			frameTop            = 0;
			frameBottom         = frameHeight;
            //DRT Panels
            drtLeft             = 0;
			drtRight            = frameRight;
			// Sprite positions
            p1Start             = frameLeft+(frameWidth*0.33 - pWidth/2);
            p2Start             = frameRight-(frameWidth*0.33 + pWidth/2);
            py                  = frameBottom - pHeight*3;
            bx                  = [frameRight-(frameWidth/2-bRad*4), frameRight-frameWidth/2, frameRight-(frameWidth/2+bRad*4)];
            by                  = py-bRad;
            disableScroll();

            if (state.status === 'playing') {
                console.log(state.block);
                clearTimeout(timeout)
                nCurrentTrial = state.trialNo+1;
                moving  = true;
                start   = state['players'][state.player_id]['trialStart'];
                startCount++
                scoreReset();
                expTrial();
                proceed = false;
                bInBlockInstructions = false;
                bInPractice = false;
            } else if (state.status === 'reading' && state.trialNo+1 > 1){
                clearTimeout(timeout)
                bInTrialBreak=true;
                bInTrial    = false;
                moving      = false;
                dispCont    = true;
                startCount  = 0;
                nCurrentTrial = state.trialNo;
                interTrial(score1,score2,teamScore, state.block.block_type);   
            } else if (skipIntro){
                blockInst(state.block.block_type, nCurrentBlock);
            } else {
                getUsername1();
            }
        }
        //Addin
        function getUsername1() {
            //var username = jatos.studySessionData.SonaID;
            if (username1 == null) {
                username1 = prompt("Participant 1, please enter your 5 or 6 digit SONA ID");
                getUsername1();
            }
            else if (username1.length!= 5 && username1.length!=6) {
                username1 = prompt("Participant 1, please enter your 5 or 6 digit SONA ID");
                confirmUsername1();
            }
            else if (username1 != null && username1.length == 5 || username1.length == 6) {
                if (state.status === 'waiting'){
                    waitingRoom();
                } else {
                    instructions1();
                }
            }
        }

        function confirmUsername1() {
            if (username1.length != 5) {
                alert("Please ensure participant 1 username is 5 or 6 numerical characters long");
                getUsername1();
            }
            else {
                if (state.status === 'waiting'){
                    waitingRoom();
                } else {
                    instructions1();
                }
            }
        }

        function removeAllVals(arr, value) {
            var i = 0;
            let eventN = 0; // number of items removed from list
            let ePos = getAllIndexes(arr,value);
            while (i < arr.length) {
                if(arr[i] === value) {
                    arr.splice(i, 1);
                    eventN += 1;
                } else {
                    ++i;
                }
            }
            return [arr,eventN, ePos];
        }
        function getAllIndexes(arr, val) {
            var indexes = [], i;
            for(i = 0; i < arr.length; i++)
                if (arr[i] === val)
                    indexes.push(i);
            return indexes;
        }
        function mean(numbers,missID) {
            // remove misses from array, return mean without misses, and number of misses
            let array = removeAllVals(numbers,missID);

            var total = 0, i;
            for (i = 0; i < array[0].length; i += 1) {
                total += array[0][i];
            }
            return [total / array[0].length, array[1], array[2]];
        }

        function disableScroll() {
            // Get the current page scroll position
            scrollTop = window.pageYOffset || document.documentElement.scrollTop;
            scrollLeft = window.pageXOffset || document.documentElement.scrollLeft,
            // if any scroll is attempted, set this to the previous value
            window.onscroll = function() {
            window.scrollTo(scrollLeft, scrollTop);
            };
        }
        function timedContinue() {
            if (dispCont){
            expContext.fillText("Press 'spacebar' to continue.", expCanvas.width/2,expCanvas.height-200);
            proceed = true;
            }
        }
        function drawCanvas(){
            expContext.fillStyle = "rgb(0,0,0)";
			expContext.fillRect(0, 0, expCanvas.width, expCanvas.height);
        }
        function clearCanvas(){
            expContext.clearRect(0, 0, expCanvas.width, expCanvas.height);
        }
        function drawFrame(){
            expContext.beginPath();
            expContext.rect(frameLeft,frameTop,frameWidth,frameHeight);
            expContext.fillStyle = frameColour;
            expContext.fill();
            expContext.stroke();
        }
        function clearFrame(){
            expContext.clearRect(frameLeft,frameTop,frameWidth,frameHeight);
        }
        function drawDRT(stimTimes,duration,start,trialBegin = false){
            let tRem;
            let drtTimer = Date.now();
            if (trialBegin){
                tRem = (-(drtTimer-start)/1000)+duration;
            } else {
                tRem = duration;
            }

            if (drtResp1){
                if (stimTimes[0]-tRem > rtMin && counter1){
                    rt1.push(stimTimes[0]-tRem);
                    ws.send(JSON.stringify({'rt' : stimTimes[0] - tRem}))
                    counter1 = false;
                } else {
                    fa1.push(tRem);
                    ws.send(JSON.stringify({'fa': tRem}))
                }
                drtResp1 = false;
            }
            
            if (tRem > stimTimes[0]){
                drtResp1 = false; 
                drtPanels.draw(drtOff);
            }
            if (tRem < stimTimes[0] && tRem > stimTimes[0]-drtDur && drtResp1==false && counter1){
                drtPanels.draw(drtOn);
            }
            if (tRem < stimTimes[0]-respWin){
                onsets.push(stimTimes[0]);
                stimTimes.shift();
                if (counter1){ // if still true at this point then no response was made to this stimulus
                    rt1.push(-1); // -1 == a miss
                    ws.send(JSON.stringify({'rt': -1}))
                } 
                else {
                    counter1 = true;
                }
            }

            expContext.fill();
            expContext.stroke();
        }

        function scoring(){
            playerId = state.player_id;
            otherId = playerId === '0' ? '1' : '0';
            hits1 = state.players[playerId]['hits']
            hits2 = state.players[otherId]['hits']
            miss1 = state.players[playerId]['miss']
            miss2 = state.players[otherId]['miss']
            if (hits1 == 0){score1=0} else {score1=(Math.round((hits1/(hits1+miss1))*1000)).toFixed(0)}
            if (hits2 == 0){score2=0} else {score2=(Math.round((hits2/(hits2+miss2))*1000)).toFixed(0)}
            if(state.block.block_type=="col" || state.block.block_type=="com"){
                if (hits1 == 0 && hits2 == 0){
                    teamScore = 0;
                }   else {
                    teamScore = (Math.round(((hits1+hits2)/(hits1+hits2+miss1))*1000)).toFixed(0);
                }
            }
        }
        function scoreReset(){
            hits1       = 0;
            miss1       = 0;
            score1      = 0;
            hits2       = 0;
            miss2       = 0;
            score2      = 0;
            teamScore   = 0;
            p1teamScore = 0;
            p2teamScore = 0;
            rt1         = [];
            rt2         = [];
            fa1         = [];
            fa2         = [];
            onsets      = [];
        }
        function drawScore(blockType,currentBlock){
            if (blockType=="col"){
                expContext.textAlign = "left";
                expContext.font = "16px Arial";
                expContext.fillStyle = "rgb(0,0,0)";
                expContext.fillText("Team Score: "+teamScore,frameLeft+10,frameTop+20);

                expContext.textAlign = "right";
                expContext.fillText("Team Score: "+teamScore,frameRight-10,frameTop+20);
            } else {
                // Player 1 Score
                expContext.textAlign = "left";
                expContext.font = "16px Arial";
                expContext.fillStyle = "rgb(0,0,0)";
                expContext.fillText("Your Score: "+score1,frameLeft+10,frameTop+20);

                // Player 2 Score
                expContext.textAlign = "right";
                expContext.fillStyle = "rgb(0,0,0)";
                expContext.fillText("Player 2 Score: "+score2,frameRight-10,frameTop+20);
            }
        }
        function drawTimer(duration, start, trialBegin = false){
            let timeRemaining;
            let startTime = Date.now();
            if (trialBegin){
                timeRemaining = (-(startTime-start)/1000)+duration;
            } else {
                timeRemaining = duration;
            }
            let dispTime = timeRemaining.toFixed(2);
            expContext.font = "16px Arial";
            expContext.fillStyle = "rgb(0,0,0)";
            expContext.textAlign = "center";
            expContext.fillText(dispTime+'s',frameLeft+frameWidth/2,frameTop+20);

            if (bInPractice){
                drawPracInst(timeRemaining);
            }
            return timeRemaining;
        }
        function uniqueAngles(nBalls,min,max) {
            let counter = 0;
            let angles = new Array();
            while (counter < nBalls*2){
                let newAngle = Math.floor(Math.random()*(max-min)+min);
                if (angles.includes(newAngle)) {
                    continue;
                } else{
                    angles.push(newAngle);
                    counter++;
                }
            }
            return angles;
        }
        function deg2rad(degrees) {
            var pi = Math.PI;
            return degrees*(pi/180);
        }
        function randRange(min,max){
            return Math.random()*(max-min)+min;
        }
        function trialShuffle(trialTypes){
            for (let i = trialTypes.length - 1; i > 0; i--) {
                let j = Math.floor(Math.random() * (i + 1)); // random index from 0 to i
                [trialTypes[i], trialTypes[j]] = [trialTypes[j], trialTypes[i]];
            }
            return trialTypes;
        }
        function drtStimTimes(min,max){
            let drtTimes    = [max-randRange(drtMin,drtMax)];
            while (drtTimes.slice(-1)>min){
                drtTimes.push(drtTimes.slice(-1)-randRange(drtMin,drtMax));
            }
            drtTimes.pop()
            return drtTimes;
        }

        function drawPracticeTrial(drawStartTime){
            bInTrial = true;
            bInTrialBreak = false
            dispCont = false;
            if (!drawStartTime){
                drawStartTime = drawStartTime;
            }
            if(!startingTime){startingTime=drawStartTime;}
            if(!lastTime){lastTime=drawStartTime;}
            totalElapsedTimed=(drawStartTime-startingTime);
            elapsedSinceLastLoop=(drawStartTime-lastTime);
            lastTime=drawStartTime;

            let frProp = pSpeed * elapsedSinceLastLoop / 60;
            let speedCorrected = pSpeed * frProp;
            let ballSpeedCorrected = bSpeed * frProp;
            if (!ballSpeedCorrected){
                ballSpeedCorrected = bSpeed;
            }
            
            drawCanvas();
            drawDRT(drtOnsets,trialDuration,start,moving);
            drawFrame();
            allBalls.forEach(function(ball){ // ball is the name of each element in the object, same as [for balls in balllist: ball.draw()]
                ball.draw();
                ball.speed = ballSpeedCorrected;
                ball.movePractice(paddle1.x);
            })
            paddle1.draw(); paddle1.move(p1Left,p1Right, speedCorrected);

            scoring();
            drawScore(state.block.block_type,nCurrentBlock);
            trialTime = drawTimer(trialDuration, start, moving);

            rAF = requestAnimationFrame(drawPracticeTrial)
            if (trialTime <= 0){
                endTrial()
            };
        }

        function drawTrial(drawStartTime){
            bInTrial = true;
            bInTrialBreak = false
            dispCont = false;
            if (!drawStartTime){
                drawStartTime = drawStartTime;
            }
            if(!startingTime){startingTime=drawStartTime;}
            if(!lastTime){lastTime=drawStartTime;}
            totalElapsedTimed=(drawStartTime-startingTime);
            elapsedSinceLastLoop=(drawStartTime-lastTime);
            lastTime=drawStartTime;
            let frProp = pSpeed * elapsedSinceLastLoop / 60;
            let bProp   = bSpeed * (messageDelay) / 60;
            let speedCorrected = pSpeed * frProp;
            // let ballSpeedCorrected = bSpeed * bProp;

            let now = adjustedTime()
            let elapsed = now - (state.timestamp*1000);
            let ballSpeedCorrected = bSpeed * (bSpeed * elapsed / 60);
            
            drawCanvas();
            drawDRT(drtOnsets,trialDuration,start,moving);
            drawFrame();

            paddle1.move(p1Left,p1Right,speedCorrected);
            paddle2.move(p2Left,p2Right,speedCorrected);
            paddle1History.add(now, paddle1.x);

            allBalls.forEach(function(ball){
                ball.move(this.paddle1.x, this.paddle2.x, elapsed);
                ball.draw();

                ball.xCoords.push([ball.x, ball.y])
            })

            paddle1.draw();
            paddle2.draw();

            scoring();
            drawScore(state.block.block_type,nCurrentBlock);
            trialTime = drawTimer(trialDuration, start, moving);

            rAF = requestAnimationFrame(drawTrial)
            if (trialTime <= 0){
                endTrial()
            }

        }
        function expTrial(){
            drtOnsets = state.drt.onset
            drtPanels   = new DRT();
            p1Balls     =[];
            p2Balls     =[];
            allBalls    =[];
            justOncePlease = true; // For the calculation of cumulative scores
            
            playerId = state.player_id;
            otherId = playerId === '0' ? '1' : '0';

            if (state.block.block_type=="nonCol"){
                for (let i = 0; i < state.block.n_balls; i++){
                    p1Balls.push(new Ball(state.balls[i].x, pColours[parseInt(playerId)], state.balls[i].id, state.balls[i].angle));
                    allBalls.push(new Ball(state.balls[i].x, pColours[parseInt(playerId)], state.balls[i].id, state.balls[i].angle));
                }
                for (let i = state.block.n_balls; i < state.block.n_balls*2; i++){
                    p2Balls.push(new Ball(state.balls[i].x, pColours[parseInt(otherId)], state.balls[i].id, state.balls[i].angle));
                    allBalls.push(new Ball(state.balls[i].x, pColours[parseInt(otherId)], state.balls[i].id, state.balls[i].angle));
                }
            } else {
                for (let i = 0; i < state.block.n_balls*2; i++){
                    allBalls.push(new Ball(state.balls[i].x, sharedColour, state.balls[i].id, state.balls[i].angle));
                }
            }

            paddle1     = new Paddle(state.players[playerId].pos, p1Colour);
            paddle2     = new Paddle(state.players[otherId].pos, p2Colour);

            let drawStartTime = null;
            let rAf;
            
            drawTrial();

        }

        async function writeMessages() {

            let sleep = function(time) {
                return new Promise((resolve) => setTimeout(resolve, time));
            }

            while (true) {

                if (state.status === 'playing' && paddle1) {
                    ws.send(JSON.stringify({ 'pos': paddle1.x, serverTimeDelta, messageDelay }));
                    await sleep(50);
                }
                else {
                    await sleep(500);
                }
            }
        }

        async function readMessages() {

            for await (const message of messages) {

                let received = JSON.parse(message);

                let serverTime = parseInt(1000 * received.timestamp);
                let clientTime = Date.now();
                let delta = serverTime - clientTime;

                if (serverTimeDelta === undefined) {
                    serverTimeDelta = delta;
                    messageDelay = 0;
                }
                else if (delta > serverTimeDelta) {
                    serverTimeDelta = delta;
                    messageDelay = 0;
                }
                else {
                    messageDelay = clientTime + serverTimeDelta - serverTime;
                }

                if (state.status === 'waiting' && received.status === 'reading'){
                    instructions1();                
                }


                if (state.status === 'reading' && received.status === 'playing') {
                    // transitioning from reading to playing (i.e. beginning trial)
                    Object.assign(state, received);
                    console.log(state.block);
                    clearTimeout(timeout)
                    nCurrentTrial = state.trialNo+1;

                    if (startCount == 0){
                        moving  = true;
                        start   = Date.now();
                        ws.send(JSON.stringify({ 'trialStart': start}));
                        startCount++
                    }
                    scoreReset();
                    
                    expTrial();
                    proceed = false;
                    bInBlockInstructions = false;
                    bInPractice = false;
                }

                if (state.status === 'playing' && received.status === 'reading') {
                    // transitioning from playing to reading (i.e. end of trial)
                    Object.assign(state, received);
                    startCount = 0;
                    moving = false;
                    endTrial()
                    console.log('trial end');
                    console.log('begin instructions for next block');
                    console.log(`block type ${ JSON.stringify(state.block) }`);
                }

                if (received.status === 'playing') {

                    let playerId = state.player_id;
                    let otherId = playerId === '0' ? '1' : '0';
                    paddle2History.add(parseInt(received.timestamp*1000), received.players[otherId].pos)
                }

                Object.assign(state, received);
                notifyStateReady();
            }
        }

        function practiceTrial(){
            bInPractice = true;
            drtOnsets   = drtStimTimes(respWin,trialDuration/2);
            drtPanels   = new DRT();
            let nPracBalls  = 2;
            bAngles     = uniqueAngles(nPracBalls,60, 120);
            for (let i = 0; i < nPracBalls; i++){
                allBalls.push(new Ball(bx[i%3], sharedColour, i, bAngles[i]));
            }
            playerId = state.player_id;
            otherId = playerId === '0' ? '1' : '0';
            paddle1     = new Paddle(state.players[playerId].pos, p1Colour);
            
            let drawStartTime = null;
            let rAf;
            drawPracticeTrial()
        }
        function endTrial(){
            cancelAnimationFrame(rAF);
            clearFrame();
            bInTrialBreak=true;
            bInTrial    = false;
            moving      = false;
            dispCont    = true;
            startCount  = 0;
            if (bInPractice){
                blockInst(state.block.block_type,nCurrentBlock);
            } else if (bInTrialBreak){
                interTrial(score1,score2,teamScore, state.block.block_type)
            }
        }

        var p1DRTtrialData;
        var p2DRTtrialData;
        var p1MissEvents;
        var p2MissEvents;

        function interTrial(p1s, p2s, teams, blockType){
            drawCanvas();
			expContext.fillStyle = frameColour;
            expContext.font="16px Arial";
            expContext.textAlign = "center";
            expContext.fillText("Trial "+nCurrentTrial+" of "+state.maxTrials +" completed.",expCanvas.width/2,expCanvas.height/5);
            // This notation is whack. Essentially - prepend a string with + to evaluate as a number
            p1teamScore = Math.round((+p1s/(+p1s + +p2s))*+teams);
            p2teamScore = parseInt(teams-p1teamScore); // you can't use addition with parseInt
            if (justOncePlease){
                p1CumulativeScore += parseInt(p1s);
                p2CumulativeScore += parseInt(p2s);
                teamCumulativeScore+=parseInt(teams);
                justOncePlease = false;
            }
            if (blockType == "nonCol" || blockType == "com"){
                expContext.fillText("You:",p1Start+pWidth/2,frameTop+frameHeight/4+100);
                expContext.fillText("Player 2:",p2Start+pWidth/2,frameTop+frameHeight/4+100);
                expContext.fillText("Trial Score",frameRight-frameWidth/2,frameTop+frameHeight/4+125);
                expContext.fillText("Total Score",frameRight-frameWidth/2,frameTop+frameHeight/4+175);
                expContext.fillText(p1s,p1Start+pWidth/2,frameTop+frameHeight/4+125);
                expContext.fillText(p2s,p2Start+pWidth/2,frameTop+frameHeight/4+125);
                expContext.fillText(p1CumulativeScore,p1Start+pWidth/2,frameTop+frameHeight/4+175);
                expContext.fillText(p2CumulativeScore,p2Start+pWidth/2,frameTop+frameHeight/4+175);

            } else { // collaborative
                expContext.fillText("You:",p1Start+pWidth/2,frameTop+frameHeight/4+100);
                expContext.fillText("Player 2:",p2Start+pWidth/2,frameTop+frameHeight/4+100);
                expContext.fillText("Team: ",expCanvas.width/2,frameTop+frameHeight/4);
                expContext.fillText("Trial Score",p1Start+pWidth/2,frameTop+frameHeight/4+25);
                expContext.fillText("Total Score",p1Start+pWidth/2,frameTop+frameHeight/4+50);
                expContext.fillText(p1teamScore,p1Start+pWidth/2,frameTop+frameHeight/4+125);
                expContext.fillText(p2teamScore,p2Start+pWidth/2,frameTop+frameHeight/4+125);
                expContext.fillText(teams,expCanvas.width/2,frameTop+frameHeight/4+25);
                expContext.fillText(teamCumulativeScore,expCanvas.width/2,frameTop+frameHeight/4+50);
            }
            timeout = setTimeout(timedContinue,trialBreakTime*1000);
        }
        function expEnd(){
            drawCanvas();
            expContext.fillStyle = frameColour;
            expContext.font="30px Arial";
            expContext.textAlign = "center";
            expContext.fillText("The experiment is complete!",expCanvas.width/2,expCanvas.height/4-100);
            expContext.font="16px Arial";
            expContext.fillText("Thank you for your participation.",expCanvas.width/2,expCanvas.height/4-50);
            expContext.fillText("If you have any questions or concerns about the experiment please contact the", expCanvas.width/2, expCanvas.height/4-25);
            expContext.filltext("researchers Murray Bennett or Ami Eidels at murray.bennett@uon.edu.au or ami.eidels@newcastle.edu.au.",expCanvas.width/2,expCanvas.height/4-25);
            expContext.fillText("Participation credit has been automatically granted.",expCanvas.width/2,expCanvas.height/4+25);
        }
/*
		function pointsLink() {
            // Link participant 1 points
        	var url = "https://newcastle.sona-systems.com/services/SonaAPI.svc/WebstudyCredit?experiment_id=1059&credit_token=ef8c1a701a954d229c4e02cd70842ad5&survey_code=" + username1;
        	var xhttp = new XMLHttpRequest();
        	xhttp.open("GET", url, true);
			xhttp.send();

            // link participant 2 points
            var url = "https://newcastle.sona-systems.com/services/SonaAPI.svc/WebstudyCredit?experiment_id=1059&credit_token=ef8c1a701a954d229c4e02cd70842ad5&survey_code=" + username2;
        	var xhttp = new XMLHttpRequest();
        	xhttp.open("GET", url, true);
			xhttp.send();
        }*/
    </script>
  </BODY>
</HTML>